2025-03-25-14-30-00 163 1 def generate_color_palette(num_colors: int) -> List[Tuple[int, int, int]]:     """     Generates a color palette with a specified number of distinct colors.          Parameters:     - num_colors (int): Number of distinct colors to generate.          Returns:     - list of RGB tuples representing colors.     """     # YOUR CODE HERE     palette = set()     while len(palette) < num_colors:         color = tuple(int(c) for c in np.random.randint(50, 206, size=3))         palette.add(color)     return list(palette)  def scale_image(image: np.ndarray, num_pixels: int) -> np.ndarray:     """     Scales an image to the desired size.          Parameters:     - image (np.ndarray): The input image.     - num_pixels (int): Desired size for width and height.          Returns:     - np.ndarray: Rescaled image.     """     # YOUR CODE HERE     return cv2.resize(image, (num_pixels, num_pixels), interpolation=cv2.INTER_AREA)  def check_overlap(center: Tuple[int, int], size: int, existing_shapes: List[dict]) -> bool:     """     Checks if a new shape overlaps with existing shapes.          Parameters:     - center (Tuple[int, int]): Center of the new shape.     - size (int): Size of the new shape.     - existing_shapes (List[dict]): List of existing shapes.          Returns:     - bool: True if there is an overlap, False otherwise.     """     # YOUR CODE HERE     x, y = center          for shape in existing_shapes:         ex, ey, esize, etype = shape["center"][0], shape["center"][1], shape["size"], shape["type"]          if etype == "circle":             # Use Euclidean distance for circle overlaps             distance = np.sqrt((x - ex) ** 2 + (y - ey) ** 2)             if distance < (size + esize):                   return True  # Overlap detected          else:  # Squares and Triangles (Bounding Box Method)             if abs(x - ex) < (size + esize) and abs(y - ey) < (size + esize):                 return True  # Overlap detected      return False  def draw_circle(image: np.ndarray, center: Tuple[int, int], size: int, color: Tuple[int, int, int]) -> float:     """     Draws a circle on an image.          Returns:     - float: Area of the circle.     """     # YOUR CODE HERE     cv2.circle(image, center, size, color, -1)  # Draw filled circle     return np.pi * (size ** 2)  # Compute area  def draw_square(image: np.ndarray, center: Tuple[int, int], size: int, color: Tuple[int, int, int]) -> int:     """     Draws a square on an image.          Returns:     - int: Area of the square.     """     # YOUR CODE HERE     top_left = (center[0] - size, center[1] - size)     bottom_right = (center[0] + size, center[1] + size)     cv2.rectangle(image, top_left, bottom_right, color, -1)  # Draw filled square     return (2 * size) ** 2  # Compute area  def draw_triangle(image: np.ndarray, center: Tuple[int, int], size: int, color: Tuple[int, int, int]) -> float:     """     Draws a triangle on an image.          Returns:     - float: Area of the triangle.     """     # YOUR CODE HERE     # Define three triangle vertices     point1 = (center[0], center[1] - size)  # Top vertex     point2 = (center[0] - size, center[1] + size)  # Bottom-left vertex     point3 = (center[0] + size, center[1] + size)  # Bottom-right vertex          triangle_cnt = np.array([point1, point2, point3])  # Convert to NumPy array     cv2.fillPoly(image, [triangle_cnt], color)  # Draw filled triangle      # Compute triangle area (equilateral)     height = (np.sqrt(3) / 2) * (2 * size)     return 0.5 * (2 * size) * height  # (1/2 * base * height)   def generate_image(img_size: int, num_pixels: int, color_palette: List[Tuple[int, int, int]], max_shapes: int = 10) -> Tuple[np.ndarray, List[dict]]:     """     Generates an image with at least one circle, one square, and one triangle.     Uses helper functions for shape drawing and scaling.          Parameters:     - img_size (int): Size of the generated image before scaling.     - num_pixels (int): Final size of the image after scaling.     - color_palette (List[Tuple[int, int, int]]): List of available colors.          Returns:     - np.ndarray: Generated image.     - List[dict]: Metadata for shapes in the image.     """     # YOUR CODE HERE     image = np.ones((img_size, img_size, 3), dtype=np.uint8) * 255     shapes_metadata = []  # To store details of added shapes      # Ensure we place at least 1 circle, 1 square, and 1 triangle     shape_types = ["circle", "square", "triangle"]          for shape_type in shape_types + random.choices(shape_types, k=max_shapes - len(shape_types)):  # Ensure min shapes, then random         max_attempts = 20  # Avoid infinite loops         for _ in range(max_attempts):             # Generate a random position and size             center = (random.randint(20, img_size - 20), random.randint(20, img_size - 20))             size = random.randint(10, 30)             color = random.choice(color_palette)              # Check if this new shape overlaps with existing ones             if not check_overlap(center, size, shapes_metadata):                 if shape_type == "circle":                     area = draw_circle(image, center, size, color)                 elif shape_type == "square":                     area = draw_square(image, center, size, color)                 else:                     area = draw_triangle(image, center, size, color)                                  # Store shape metadata                 shapes_metadata.append({"type": shape_type, "center": center, "size": size, "area": area})                 break  # Move to the next shape          # Resize the image to num_pixels x num_pixels     image = scale_image(image, num_pixels)          return image, shapes_metadata  def assign_label(shapes_metadata: List[dict], fraction: float = 0.5) -> int:     """     Assigns a label based on a fractional comparison of the largest circle and square areas.          Returns:     - int: 0 if the largest square area is significantly larger than the largest circle area,            2 if the largest circle area is significantly larger than the largest square area,            1 otherwise.     """     # YOUR CODE HERE     raise NotImplementedError()  def generate_dataset(num_samples: int, img_size: int, num_pixels: int, num_colors: int, fraction: float = 2.0, max_shapes: int = 10) -> Tuple[np.ndarray, np.ndarray]:     """     Generates a dataset of images and labels in memory.          Returns:     - tuple[np.ndarray, np.ndarray]: Images (X) and labels (y).     """     # YOUR CODE HERE     raise NotImplementedError()  def display_sample_images(X: np.ndarray, y: np.ndarray, num_samples: int = 5) -> None:     """     Displays randomly sampled images from the dataset with labels.     """     # YOUR CODE HERE     raise NotImplementedError()      save_history()
2025-03-25-14-30-00 163 2 get_ipython().run_line_magic('matplotlib', 'inline') import matplotlib.pyplot as plt import numpy as np import scipy as sp import cv2 import random import pandas as pd from typing import List, Tuple, Callable, Optional from submission_utils import save_history, check_and_prepare_for_submission # import warnings filter from warnings import simplefilter # ignore all future warnings simplefilter(action='ignore', category=FutureWarning)
2025-03-25-14-30-00 163 3 def generate_color_palette(num_colors: int) -> List[Tuple[int, int, int]]:     """     Generates a color palette with a specified number of distinct colors.          Parameters:     - num_colors (int): Number of distinct colors to generate.          Returns:     - list of RGB tuples representing colors.     """     # YOUR CODE HERE     palette = set()     while len(palette) < num_colors:         color = tuple(int(c) for c in np.random.randint(50, 206, size=3))         palette.add(color)     return list(palette)  def scale_image(image: np.ndarray, num_pixels: int) -> np.ndarray:     """     Scales an image to the desired size.          Parameters:     - image (np.ndarray): The input image.     - num_pixels (int): Desired size for width and height.          Returns:     - np.ndarray: Rescaled image.     """     # YOUR CODE HERE     return cv2.resize(image, (num_pixels, num_pixels), interpolation=cv2.INTER_AREA)  def check_overlap(center: Tuple[int, int], size: int, existing_shapes: List[dict]) -> bool:     """     Checks if a new shape overlaps with existing shapes.          Parameters:     - center (Tuple[int, int]): Center of the new shape.     - size (int): Size of the new shape.     - existing_shapes (List[dict]): List of existing shapes.          Returns:     - bool: True if there is an overlap, False otherwise.     """     # YOUR CODE HERE     x, y = center          for shape in existing_shapes:         ex, ey, esize, etype = shape["center"][0], shape["center"][1], shape["size"], shape["type"]          if etype == "circle":             # Use Euclidean distance for circle overlaps             distance = np.sqrt((x - ex) ** 2 + (y - ey) ** 2)             if distance < (size + esize):                   return True  # Overlap detected          else:  # Squares and Triangles (Bounding Box Method)             if abs(x - ex) < (size + esize) and abs(y - ey) < (size + esize):                 return True  # Overlap detected      return False  def draw_circle(image: np.ndarray, center: Tuple[int, int], size: int, color: Tuple[int, int, int]) -> float:     """     Draws a circle on an image.          Returns:     - float: Area of the circle.     """     # YOUR CODE HERE     cv2.circle(image, center, size, color, -1)  # Draw filled circle     return np.pi * (size ** 2)  # Compute area  def draw_square(image: np.ndarray, center: Tuple[int, int], size: int, color: Tuple[int, int, int]) -> int:     """     Draws a square on an image.          Returns:     - int: Area of the square.     """     # YOUR CODE HERE     top_left = (center[0] - size, center[1] - size)     bottom_right = (center[0] + size, center[1] + size)     cv2.rectangle(image, top_left, bottom_right, color, -1)  # Draw filled square     return (2 * size) ** 2  # Compute area  def draw_triangle(image: np.ndarray, center: Tuple[int, int], size: int, color: Tuple[int, int, int]) -> float:     """     Draws a triangle on an image.          Returns:     - float: Area of the triangle.     """     # YOUR CODE HERE     # Define three triangle vertices     point1 = (center[0], center[1] - size)  # Top vertex     point2 = (center[0] - size, center[1] + size)  # Bottom-left vertex     point3 = (center[0] + size, center[1] + size)  # Bottom-right vertex          triangle_cnt = np.array([point1, point2, point3])  # Convert to NumPy array     cv2.fillPoly(image, [triangle_cnt], color)  # Draw filled triangle      # Compute triangle area (equilateral)     height = (np.sqrt(3) / 2) * (2 * size)     return 0.5 * (2 * size) * height  # (1/2 * base * height)   def generate_image(img_size: int, num_pixels: int, color_palette: List[Tuple[int, int, int]], max_shapes: int = 10) -> Tuple[np.ndarray, List[dict]]:     """     Generates an image with at least one circle, one square, and one triangle.     Uses helper functions for shape drawing and scaling.          Parameters:     - img_size (int): Size of the generated image before scaling.     - num_pixels (int): Final size of the image after scaling.     - color_palette (List[Tuple[int, int, int]]): List of available colors.          Returns:     - np.ndarray: Generated image.     - List[dict]: Metadata for shapes in the image.     """     # YOUR CODE HERE     image = np.ones((img_size, img_size, 3), dtype=np.uint8) * 255     shapes_metadata = []  # To store details of added shapes      # Ensure we place at least 1 circle, 1 square, and 1 triangle     shape_types = ["circle", "square", "triangle"]          for shape_type in shape_types + random.choices(shape_types, k=max_shapes - len(shape_types)):  # Ensure min shapes, then random         max_attempts = 20  # Avoid infinite loops         for _ in range(max_attempts):             # Generate a random position and size             center = (random.randint(20, img_size - 20), random.randint(20, img_size - 20))             size = random.randint(10, 30)             color = random.choice(color_palette)              # Check if this new shape overlaps with existing ones             if not check_overlap(center, size, shapes_metadata):                 if shape_type == "circle":                     area = draw_circle(image, center, size, color)                 elif shape_type == "square":                     area = draw_square(image, center, size, color)                 else:                     area = draw_triangle(image, center, size, color)                                  # Store shape metadata                 shapes_metadata.append({"type": shape_type, "center": center, "size": size, "area": area})                 break  # Move to the next shape          # Resize the image to num_pixels x num_pixels     image = scale_image(image, num_pixels)          return image, shapes_metadata  def assign_label(shapes_metadata: List[dict], fraction: float = 0.5) -> int:     """     Assigns a label based on a fractional comparison of the largest circle and square areas.          Returns:     - int: 0 if the largest square area is significantly larger than the largest circle area,            2 if the largest circle area is significantly larger than the largest square area,            1 otherwise.     """     # YOUR CODE HERE     raise NotImplementedError()  def generate_dataset(num_samples: int, img_size: int, num_pixels: int, num_colors: int, fraction: float = 2.0, max_shapes: int = 10) -> Tuple[np.ndarray, np.ndarray]:     """     Generates a dataset of images and labels in memory.          Returns:     - tuple[np.ndarray, np.ndarray]: Images (X) and labels (y).     """     # YOUR CODE HERE     raise NotImplementedError()  def display_sample_images(X: np.ndarray, y: np.ndarray, num_samples: int = 5) -> None:     """     Displays randomly sampled images from the dataset with labels.     """     # YOUR CODE HERE     raise NotImplementedError()      save_history()
2025-03-25-14-30-00 163 4 def generate_color_palette(num_colors: int) -> List[Tuple[int, int, int]]:     """     Generates a color palette with a specified number of distinct colors.          Parameters:     - num_colors (int): Number of distinct colors to generate.          Returns:     - list of RGB tuples representing colors.     """     # YOUR CODE HERE     palette = set()     while len(palette) < num_colors:         color = tuple(int(c) for c in np.random.randint(50, 206, size=3))         palette.add(color)     return list(palette)  def scale_image(image: np.ndarray, num_pixels: int) -> np.ndarray:     """     Scales an image to the desired size.          Parameters:     - image (np.ndarray): The input image.     - num_pixels (int): Desired size for width and height.          Returns:     - np.ndarray: Rescaled image.     """     # YOUR CODE HERE     return cv2.resize(image, (num_pixels, num_pixels), interpolation=cv2.INTER_AREA)  def check_overlap(center: Tuple[int, int], size: int, existing_shapes: List[dict]) -> bool:     """     Checks if a new shape overlaps with existing shapes.          Parameters:     - center (Tuple[int, int]): Center of the new shape.     - size (int): Size of the new shape.     - existing_shapes (List[dict]): List of existing shapes.          Returns:     - bool: True if there is an overlap, False otherwise.     """     # YOUR CODE HERE     x, y = center          for shape in existing_shapes:         ex, ey, esize, etype = shape["center"][0], shape["center"][1], shape["size"], shape["type"]          if etype == "circle":             # Use Euclidean distance for circle overlaps             distance = np.sqrt((x - ex) ** 2 + (y - ey) ** 2)             if distance < (size + esize):                   return True  # Overlap detected          else:  # Squares and Triangles (Bounding Box Method)             if abs(x - ex) < (size + esize) and abs(y - ey) < (size + esize):                 return True  # Overlap detected      return False  def draw_circle(image: np.ndarray, center: Tuple[int, int], size: int, color: Tuple[int, int, int]) -> float:     """     Draws a circle on an image.          Returns:     - float: Area of the circle.     """     # YOUR CODE HERE     cv2.circle(image, center, size, color, -1)  # Draw filled circle     return np.pi * (size ** 2)  # Compute area  def draw_square(image: np.ndarray, center: Tuple[int, int], size: int, color: Tuple[int, int, int]) -> int:     """     Draws a square on an image.          Returns:     - int: Area of the square.     """     # YOUR CODE HERE     top_left = (center[0] - size, center[1] - size)     bottom_right = (center[0] + size, center[1] + size)     cv2.rectangle(image, top_left, bottom_right, color, -1)  # Draw filled square     return (2 * size) ** 2  # Compute area  def draw_triangle(image: np.ndarray, center: Tuple[int, int], size: int, color: Tuple[int, int, int]) -> float:     """     Draws a triangle on an image.          Returns:     - float: Area of the triangle.     """     # YOUR CODE HERE     # Define three triangle vertices     point1 = (center[0], center[1] - size)  # Top vertex     point2 = (center[0] - size, center[1] + size)  # Bottom-left vertex     point3 = (center[0] + size, center[1] + size)  # Bottom-right vertex          triangle_cnt = np.array([point1, point2, point3])  # Convert to NumPy array     cv2.fillPoly(image, [triangle_cnt], color)  # Draw filled triangle      # Compute triangle area (equilateral)     height = (np.sqrt(3) / 2) * (2 * size)     return 0.5 * (2 * size) * height  # (1/2 * base * height)   def generate_image(img_size: int, num_pixels: int, color_palette: List[Tuple[int, int, int]], max_shapes: int = 10) -> Tuple[np.ndarray, List[dict]]:     """     Generates an image with at least one circle, one square, and one triangle.     Uses helper functions for shape drawing and scaling.          Parameters:     - img_size (int): Size of the generated image before scaling.     - num_pixels (int): Final size of the image after scaling.     - color_palette (List[Tuple[int, int, int]]): List of available colors.          Returns:     - np.ndarray: Generated image.     - List[dict]: Metadata for shapes in the image.     """     # YOUR CODE HERE     image = np.ones((img_size, img_size, 3), dtype=np.uint8) * 255     shapes_metadata = []  # To store details of added shapes      # Ensure we place at least 1 circle, 1 square, and 1 triangle     shape_types = ["circle", "square", "triangle"]          for shape_type in shape_types + random.choices(shape_types, k=max_shapes - len(shape_types)):  # Ensure min shapes, then random         max_attempts = 20  # Avoid infinite loops         for _ in range(max_attempts):             # Generate a random position and size             center = (random.randint(20, img_size - 20), random.randint(20, img_size - 20))             size = random.randint(10, 30)             color = random.choice(color_palette)              # Check if this new shape overlaps with existing ones             if not check_overlap(center, size, shapes_metadata):                 if shape_type == "circle":                     area = draw_circle(image, center, size, color)                 elif shape_type == "square":                     area = draw_square(image, center, size, color)                 else:                     area = draw_triangle(image, center, size, color)                                  # Store shape metadata                 shapes_metadata.append({"type": shape_type, "center": center, "size": size, "area": area})                 break  # Move to the next shape          # Resize the image to num_pixels x num_pixels     image = scale_image(image, num_pixels)          return image, shapes_metadata  def assign_label(shapes_metadata: List[dict], fraction: float = 0.5) -> int:     """     Assigns a label based on a fractional comparison of the largest circle and square areas.          Returns:     - int: 0 if the largest square area is significantly larger than the largest circle area,            2 if the largest circle area is significantly larger than the largest square area,            1 otherwise.     """     # YOUR CODE HERE     # Extract areas of circles and squares     max_circle_area = max((shape["area"] for shape in shapes_metadata if shape["type"] == "circle"), default=0)     max_square_area = max((shape["area"] for shape in shapes_metadata if shape["type"] == "square"), default=0)      # Compare areas     if max_square_area > (1 + fraction) * max_circle_area:         return 0  # Square is much larger     elif max_circle_area > (1 + fraction) * max_square_area:         return 2  # Circle is much larger     else:         return 1  # They are similar in size  def generate_dataset(num_samples: int, img_size: int, num_pixels: int, num_colors: int, fraction: float = 2.0, max_shapes: int = 10) -> Tuple[np.ndarray, np.ndarray]:     """     Generates a dataset of images and labels in memory.          Returns:     - tuple[np.ndarray, np.ndarray]: Images (X) and labels (y).     """     # YOUR CODE HERE     # Step 1: Generate a color palette     color_palette = generate_color_palette(num_colors)      # Step 2: Initialize storage     X = np.zeros((num_samples, num_pixels, num_pixels, 3), dtype=np.uint8)  # Image storage     y = np.zeros(num_samples, dtype=np.int32)  # Label storage      # Step 3: Generate images and labels     for i in range(num_samples):         image, shapes_metadata = generate_image(img_size, num_pixels, color_palette, max_shapes)         label = assign_label(shapes_metadata, fraction)                  # Store results         X[i] = image         y[i] = label          # Print progress         if i % 100 == 0:             print(f"Generated {i}/{num_samples} images...")      print("Dataset generation complete!")     return X, y  def display_sample_images(X: np.ndarray, y: np.ndarray, num_samples: int = 5) -> None:     """     Displays randomly sampled images from the dataset with labels.     """     # YOUR CODE HERE     raise NotImplementedError()      save_history()
2025-03-25-14-30-00 163 5 def generate_color_palette(num_colors: int) -> List[Tuple[int, int, int]]:     """     Generates a color palette with a specified number of distinct colors.          Parameters:     - num_colors (int): Number of distinct colors to generate.          Returns:     - list of RGB tuples representing colors.     """     # YOUR CODE HERE     palette = set()     while len(palette) < num_colors:         color = tuple(int(c) for c in np.random.randint(50, 206, size=3))         palette.add(color)     return list(palette)  def scale_image(image: np.ndarray, num_pixels: int) -> np.ndarray:     """     Scales an image to the desired size.          Parameters:     - image (np.ndarray): The input image.     - num_pixels (int): Desired size for width and height.          Returns:     - np.ndarray: Rescaled image.     """     # YOUR CODE HERE     return cv2.resize(image, (num_pixels, num_pixels), interpolation=cv2.INTER_AREA)  def check_overlap(center: Tuple[int, int], size: int, existing_shapes: List[dict]) -> bool:     """     Checks if a new shape overlaps with existing shapes.          Parameters:     - center (Tuple[int, int]): Center of the new shape.     - size (int): Size of the new shape.     - existing_shapes (List[dict]): List of existing shapes.          Returns:     - bool: True if there is an overlap, False otherwise.     """     # YOUR CODE HERE     x, y = center          for shape in existing_shapes:         ex, ey, esize, etype = shape["center"][0], shape["center"][1], shape["size"], shape["type"]          if etype == "circle":             # Use Euclidean distance for circle overlaps             distance = np.sqrt((x - ex) ** 2 + (y - ey) ** 2)             if distance < (size + esize):                   return True  # Overlap detected          else:  # Squares and Triangles (Bounding Box Method)             if abs(x - ex) < (size + esize) and abs(y - ey) < (size + esize):                 return True  # Overlap detected      return False  def draw_circle(image: np.ndarray, center: Tuple[int, int], size: int, color: Tuple[int, int, int]) -> float:     """     Draws a circle on an image.          Returns:     - float: Area of the circle.     """     # YOUR CODE HERE     cv2.circle(image, center, size, color, -1)  # Draw filled circle     return np.pi * (size ** 2)  # Compute area  def draw_square(image: np.ndarray, center: Tuple[int, int], size: int, color: Tuple[int, int, int]) -> int:     """     Draws a square on an image.          Returns:     - int: Area of the square.     """     # YOUR CODE HERE     top_left = (center[0] - size, center[1] - size)     bottom_right = (center[0] + size, center[1] + size)     cv2.rectangle(image, top_left, bottom_right, color, -1)  # Draw filled square     return (2 * size) ** 2  # Compute area  def draw_triangle(image: np.ndarray, center: Tuple[int, int], size: int, color: Tuple[int, int, int]) -> float:     """     Draws a triangle on an image.          Returns:     - float: Area of the triangle.     """     # YOUR CODE HERE     # Define three triangle vertices     point1 = (center[0], center[1] - size)  # Top vertex     point2 = (center[0] - size, center[1] + size)  # Bottom-left vertex     point3 = (center[0] + size, center[1] + size)  # Bottom-right vertex          triangle_cnt = np.array([point1, point2, point3])  # Convert to NumPy array     cv2.fillPoly(image, [triangle_cnt], color)  # Draw filled triangle      # Compute triangle area (equilateral)     height = (np.sqrt(3) / 2) * (2 * size)     return 0.5 * (2 * size) * height  # (1/2 * base * height)   def generate_image(img_size: int, num_pixels: int, color_palette: List[Tuple[int, int, int]], max_shapes: int = 10) -> Tuple[np.ndarray, List[dict]]:     """     Generates an image with at least one circle, one square, and one triangle.     Uses helper functions for shape drawing and scaling.          Parameters:     - img_size (int): Size of the generated image before scaling.     - num_pixels (int): Final size of the image after scaling.     - color_palette (List[Tuple[int, int, int]]): List of available colors.          Returns:     - np.ndarray: Generated image.     - List[dict]: Metadata for shapes in the image.     """     # YOUR CODE HERE     image = np.ones((img_size, img_size, 3), dtype=np.uint8) * 255     shapes_metadata = []  # To store details of added shapes      # Ensure we place at least 1 circle, 1 square, and 1 triangle     shape_types = ["circle", "square", "triangle"]          for shape_type in shape_types + random.choices(shape_types, k=max_shapes - len(shape_types)):  # Ensure min shapes, then random         max_attempts = 20  # Avoid infinite loops         for _ in range(max_attempts):             # Generate a random position and size             center = (random.randint(20, img_size - 20), random.randint(20, img_size - 20))             size = random.randint(10, 30)             color = random.choice(color_palette)              # Check if this new shape overlaps with existing ones             if not check_overlap(center, size, shapes_metadata):                 if shape_type == "circle":                     area = draw_circle(image, center, size, color)                 elif shape_type == "square":                     area = draw_square(image, center, size, color)                 else:                     area = draw_triangle(image, center, size, color)                                  # Store shape metadata                 shapes_metadata.append({"type": shape_type, "center": center, "size": size, "area": area})                 break  # Move to the next shape          # Resize the image to num_pixels x num_pixels     image = scale_image(image, num_pixels)          return image, shapes_metadata  def assign_label(shapes_metadata: List[dict], fraction: float = 0.5) -> int:     """     Assigns a label based on a fractional comparison of the largest circle and square areas.          Returns:     - int: 0 if the largest square area is significantly larger than the largest circle area,            2 if the largest circle area is significantly larger than the largest square area,            1 otherwise.     """     # YOUR CODE HERE     # Extract areas of circles and squares     max_circle_area = max((shape["area"] for shape in shapes_metadata if shape["type"] == "circle"), default=0)     max_square_area = max((shape["area"] for shape in shapes_metadata if shape["type"] == "square"), default=0)      # Compare areas     if max_square_area > (1 + fraction) * max_circle_area:         return 0  # Square is much larger     elif max_circle_area > (1 + fraction) * max_square_area:         return 2  # Circle is much larger     else:         return 1  # They are similar in size  def generate_dataset(num_samples: int, img_size: int, num_pixels: int, num_colors: int, fraction: float = 2.0, max_shapes: int = 10) -> Tuple[np.ndarray, np.ndarray]:     """     Generates a dataset of images and labels in memory.          Returns:     - tuple[np.ndarray, np.ndarray]: Images (X) and labels (y).     """     # YOUR CODE HERE     # Step 1: Generate a color palette     color_palette = generate_color_palette(num_colors)      # Step 2: Initialize storage     X = np.zeros((num_samples, num_pixels, num_pixels, 3), dtype=np.uint8)  # Image storage     y = np.zeros(num_samples, dtype=np.int32)  # Label storage      # Step 3: Generate images and labels     for i in range(num_samples):         image, shapes_metadata = generate_image(img_size, num_pixels, color_palette, max_shapes)         label = assign_label(shapes_metadata, fraction)                  # Store results         X[i] = image         y[i] = label          # Print progress         if i % 100 == 0:             print(f"Generated {i}/{num_samples} images...")      print("Dataset generation complete!")     return X, y  def display_sample_images(X: np.ndarray, y: np.ndarray, num_samples: int = 5) -> None:     """     Displays randomly sampled images from the dataset with labels.     """     # YOUR CODE HERE     unique_labels = np.unique(y)  # Get all unique class labels     num_classes = len(unique_labels)      fig, axes = plt.subplots(num_classes, num_samples, figsize=(num_samples * 2, num_classes * 2))          for i, label in enumerate(unique_labels):         # Get indices of images belonging to the current class         indices = np.where(y == label)[0]                  # Select `num_samples` images randomly (or fewer if not enough available)         selected_indices = np.random.choice(indices, min(num_samples, len(indices)), replace=False)          for j, idx in enumerate(selected_indices):             ax = axes[i, j] if num_classes > 1 else axes[j]  # Adjust for 1-row cases             ax.imshow(X[idx])  # Display the image             ax.axis("off")  # Hide axis             ax.set_title(f"Label: {label}", fontsize=10)      plt.tight_layout()     plt.show()      save_history()
2025-03-25-14-30-00 163 6 # This cell is reserved for the unit tests. Do not consider this cell.
2025-03-25-14-30-00 163 7 # This cell is reserved for the unit tests. Do not consider this cell.
2025-03-25-14-30-00 163 8 # This cell is reserved for the unit tests. Do not consider this cell.
2025-03-25-14-30-00 163 9 # This cell is reserved for the unit tests. Do not consider this cell.
2025-03-25-14-30-00 163 10 # This cell is reserved for the unit tests. Do not consider this cell.
2025-03-25-14-30-00 163 11 # This cell is reserved for the unit tests. Do not consider this cell.
2025-03-25-14-30-00 163 12 # This cell is reserved for the unit tests. Do not consider this cell.
2025-03-25-14-30-00 163 13 # This cell is reserved for the unit tests. Do not consider this cell.
2025-03-25-14-30-00 163 14 # This cell is reserved for the unit tests. Do not consider this cell.
2025-03-25-14-30-00 163 15 # This cell is reserved for the unit tests. Do not consider this cell.
2025-03-25-14-30-00 163 16 # Run the dataset generation X, y = generate_dataset(num_samples=1000, img_size=150, num_pixels=64, num_colors=3, fraction=2, max_shapes=5) display_sample_images(X, y, num_samples=5)
2025-03-25-14-30-00 163 17 # Run the dataset generation X, y = generate_dataset(num_samples=1000, img_size=150, num_pixels=64, num_colors=3, fraction=2, max_shapes=5) display_sample_images(X, y, num_samples=5)
2025-03-25-14-30-00 163 18 # Run the dataset generation X, y = generate_dataset(num_samples=1000, img_size=150, num_pixels=64, num_colors=3, fraction=2, max_shapes=5) display_sample_images(X, y, num_samples=5)
2025-03-25-14-30-00 163 19 # Run the dataset generation X, y = generate_dataset(num_samples=1000, img_size=150, num_pixels=64, num_colors=3, fraction=2, max_shapes=5) display_sample_images(X, y, num_samples=5)
